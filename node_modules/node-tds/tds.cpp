#include "tds.h"

using namespace v8;
using namespace node;


void DBConnnection::Init(v8::Handle<Object> target) {
  HandleScope scope;

  Local<FunctionTemplate> t = FunctionTemplate::New(New);

  constructor_template = Persistent<FunctionTemplate>::New(t);
  constructor_template->InstanceTemplate()->SetInternalFieldCount(1);
  constructor_template->SetClassName(String::NewSymbol("DBConnnection"));

  NODE_SET_PROTOTYPE_METHOD(constructor_template, "open",  Open);
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "close", Close);  
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "query", Query);
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "use",   Use);
  NODE_SET_PROTOTYPE_METHOD(constructor_template, "call",  Call);

  NODE_SET_METHOD(target, "init", DBConnnection::Init_);
  NODE_SET_METHOD(target, "exit", DBConnnection::Exit);
  target->Set(v8::String::NewSymbol("DBConnnection"), constructor_template->GetFunction());

  scope.Close(Undefined());
}


//初始化db-library----------------------------------------------------------------------------------------
Handle<Value> DBConnnection::Init_(const Arguments& args)
{
  HandleScope scope;
  OPT_INT_ARG(0, login_time, 5);
  OPT_INT_ARG(1, query_time, 30);
  
  dbinit();
  dberrhandle(err_handler);
  dbmsghandle(msg_handler);
  dbsettime(login_time);
  dbsetlogintime(query_time);

  scope.Close(Undefined());
  return Undefined();
} 


// 关闭db-library-----------------------------------------------------------------------------------------
Handle<Value> DBConnnection::Exit(const Arguments& args) {
  HandleScope scope;
  dbexit();
  scope.Close(Undefined());
  return Undefined();
}  


//构造Database--------------------------------------------------------------------------------------------
Handle<Value> DBConnnection::New(const Arguments& args) {
  HandleScope scope;
  DBConnnection* dbo = new DBConnnection();
  dbo->Wrap(args.This());
  scope.Close(Undefined());
  return args.This();
}


//建立DBserver连接----------------------------------------------------------------------------------------
Handle<Value> DBConnnection::Open(const Arguments& args) {
  HandleScope scope;
  
  REQ_ARGS(4);
  REQ_STR_ARG(0, host);
  REQ_STR_ARG(1, username);
  REQ_STR_ARG(2, password);
  REQ_FUN_ARG(3, cb);

  ConnInfo *conn_info = new ConnInfo;
  conn_info->self = Persistent<Object>::New(Local<Object>::New(args.This()));  
  conn_info->dbo  = ObjectWrap::Unwrap<DBConnnection>(args.This());
  conn_info->cb   = Persistent<Function>::New(cb);      

  
  STR_CPY(conn_info->host,     host);
  STR_CPY(conn_info->username, username);
  STR_CPY(conn_info->password, password);

  eio_custom(EIO_Open, EIO_PRI_DEFAULT, EIO_AfterOpen, conn_info);

  ev_ref(EV_DEFAULT_UC);
  conn_info->dbo->Ref();
  scope.Close(Undefined());
  return Undefined();
}


//--------------------------------------------------------------------------------------------------------
void DBConnnection::EIO_Open(eio_req *req) {
  ConnInfo *conn_info = (ConnInfo *)(req->data);
  DBConnnection* dbo = conn_info->dbo;

  dbo->loginrec = dblogin();
  DBSETLUSER(dbo->loginrec, conn_info->username);       
  DBSETLPWD(dbo->loginrec,  conn_info->password);
  DBSETLCHARSET(dbo->loginrec,"UTF-8");

  dbo->process = dbopen(dbo->loginrec, conn_info->host);
  
  if(dbo->process != NULL) 
      req->result = SUCCEED;
  else
      req->result = FAIL;  
} 


//--------------------------------------------------------------------------------------------------------
int DBConnnection::EIO_AfterOpen(eio_req *req) {
  ev_unref(EV_DEFAULT_UC);
  HandleScope scope;
  
  ConnInfo *conn_info = (ConnInfo *)(req->data);

  Local<Value> argv[1]; 
  if(req->result != SUCCEED){
    argv[0] = Exception::Error(String::New("[node-tds]connect db server failed"));
  }
  else{
    argv[0] = Local<Value>::New(Null());
  }
  
  TryCatch try_catch;
  conn_info->cb->Call(conn_info->self, 1, argv);
  if(try_catch.HasCaught()) {
    FatalException(try_catch);
  }
  
  conn_info->dbo->Unref();
  conn_info->cb.Dispose();
  conn_info->self.Dispose();
  delete conn_info;
  scope.Close(Undefined());
  return 0;
}
  

//关闭DBserver连接----------------------------------------------------------------------------------------
Handle<Value> DBConnnection::Close(const Arguments& args) {
  HandleScope scope;

  DBConnnection* dbo = ObjectWrap::Unwrap<DBConnnection>(args.This());

  if(dbo->process) {
    dbclose(dbo->process);  
  }  

  if(dbo->loginrec) {
    dbloginfree(dbo->loginrec);  
  }
    
  scope.Close(Undefined());
  return Undefined();
}


//使用数据库----------------------------------------------------------------------------------------------
Handle<Value> DBConnnection::Use(const Arguments& args) {
  HandleScope scope;
  
  REQ_ARGS(2);
  REQ_STR_ARG(0, dbname);
  REQ_FUN_ARG(1, cb);

  UseInfo *use_info = new UseInfo;
  use_info->dbo  = ObjectWrap::Unwrap<DBConnnection>(args.This());
  use_info->cb   = Persistent<Function>::New(cb);      
  
  STR_CPY(use_info->dbname, dbname);

  eio_custom(EIO_Use, EIO_PRI_DEFAULT, EIO_AfterUse, use_info);

  ev_ref(EV_DEFAULT_UC);
  use_info->dbo->Ref();
  scope.Close(Undefined());
  return Undefined();
}


//--------------------------------------------------------------------------------------------------------
void DBConnnection::EIO_Use(eio_req *req) {
  UseInfo *use_info = (UseInfo *)(req->data);
  DBConnnection* dbo = use_info->dbo;

  int errorCode = dbuse(dbo->process, use_info->dbname);
    
  req->result = errorCode;  
} 


//--------------------------------------------------------------------------------------------------------
int DBConnnection::EIO_AfterUse(eio_req *req){
  ev_unref(EV_DEFAULT_UC);
  HandleScope scope;
  
  UseInfo *use_info = (UseInfo *)(req->data);

  Local<Value> argv[1];

  if(req->result != SUCCEED){
      const char* def_string = "[node-tds]unable to use database";
      Persistent<Object> objError = process_error(use_info->dbo->process, def_string);  
      argv[0] = Local<Object>::New(objError);
      objError.Dispose();
  }
  else{
      argv[0] = Local<Value>::New(Null());
  }

  TryCatch try_catch;
  use_info->dbo->Unref();
  use_info->cb->Call(Context::GetCurrent()->Global(), 1, argv);
  if(try_catch.HasCaught()) {
      FatalException(try_catch);
  }

  use_info->cb.Dispose();
  delete use_info;
  scope.Close(Undefined());
  return 0;
}


//请求查询------------------------------------------------------------------------------------------------
Handle<Value> DBConnnection::Query(const Arguments& args) {
  HandleScope scope;

  REQ_ARGS(2);
  REQ_STR_ARG(0, sql);
  REQ_FUN_ARG(1, cb);

  QueryInfo *query_info = new QueryInfo;
  query_info->self = Persistent<Object>::New(Local<Object>::New(args.This())); 
  query_info->dbo  = ObjectWrap::Unwrap<DBConnnection>(args.This());
  query_info->cb   = Persistent<Function>::New(cb);  

  STR_CPY(query_info->slqString, sql);
  
  eio_custom(EIO_Query, EIO_PRI_DEFAULT, EIO_AfterQuery, query_info);

  ev_ref(EV_DEFAULT_UC);
  query_info->dbo->Ref();
  scope.Close(Undefined());
  return Undefined();
}


//--------------------------------------------------------------------------------------------------------
void DBConnnection::EIO_Query(eio_req *req) {
  QueryInfo *query_info = (QueryInfo *)(req->data);
  
  DBConnnection* dbo = query_info->dbo;

  int errorCode;

  errorCode = dbcmd(dbo->process, query_info->slqString);
  if(errorCode != SUCCEED) {
     req->result = errorCode;
     return;
  }

  errorCode = dbsqlexec(dbo->process);
  req->result = errorCode;
}


//--------------------------------------------------------------------------------------------------------
int DBConnnection::EIO_AfterQuery(eio_req *req) {
  ev_unref(EV_DEFAULT_UC);
  HandleScope scope;
  
  QueryInfo *query_info = (QueryInfo *)(req->data);

  Local<Value>  args[2];

  if(req->result != SUCCEED) {
      const char* def_string = "[node-tds]query error";
      Persistent<Object> objError = process_error(query_info->dbo->process, def_string);  
      args[0] = Local<Object>::New(objError);
      args[1] = Local<Value>::New(Null());   
      objError.Dispose();    
  }

  else { 
      Persistent<Array> rows = FetchRows(query_info->dbo);
      args[0] = Local<Value>::New(Null());      
      args[1] = Local<Array>::New(rows);
      rows.Dispose();
  }  
 
  TryCatch try_catch;
  query_info->cb->Call(query_info->self, 2, args);
  if(try_catch.HasCaught()) {
      FatalException(try_catch);
  }

  query_info->dbo->Unref();
  query_info->cb.Dispose();
  query_info->self.Dispose();
  delete query_info;
  scope.Close(Undefined());
  return 0;
}


//调用存储过程--------------------------------------------------------------------------------------------
Handle<Value> DBConnnection::Call(const Arguments& args) {
  HandleScope scope;

  REQ_ARGS(3);
  REQ_STR_ARG(0, sp_name);
  REQ_ARR_ARG(1, paramArray);
  REQ_FUN_ARG(2, cb); 
     
  SpInfo* sp_info = new SpInfo;
  sp_info->self = Persistent<Object>::New(Local<Object>::New(args.This())); 
  sp_info->dbo    = ObjectWrap::Unwrap<DBConnnection>(args.This());;
  sp_info->cb     = Persistent<Function>::New(cb);

  STR_CPY(sp_info->sp_name, sp_name);  
  // RecordSpName(sp_info->dbo->process, sp_info->sp_name);
    
  sp_info->paramCount = paramArray->Length();
  sp_info->params = new ParamInfo[sp_info->paramCount];
          
  for (int i = 0; i < sp_info->paramCount; i++) {
    Local<Object> param     = Local<Object>::Cast(paramArray->Get(i));

    String::Utf8Value  paramName(param->Get(String::New("name")));
    STR_CPY(sp_info->params[i].name, paramName); 

    sp_info->params[i].status = param->Get(String::New("status"))->IntegerValue();

    Local<Value>  value = param->Get(String::New("value"));  
    switch(param->Get(String::New("type"))->IntegerValue()){
      case 1:{                                                          
            int32_t  *number = new int32_t(value->Int32Value());
            sp_info->params[i].type     = SYBINT4;
            sp_info->params[i].datalen  = -1;
            sp_info->params[i].buflen   = -1;
            sp_info->params[i].buffer   = (BYTE*)number;
            break;}
          
      case 2:{     
            int64_t  *number = new int64_t(value->IntegerValue());                                               
            sp_info->params[i].type     = SYBINT8;
            sp_info->params[i].datalen  = -1;
            sp_info->params[i].buflen   = -1;
            sp_info->params[i].buffer   = (BYTE*)number;
            break;}
      
      case 3:{
            BYTE *number = new BYTE(value->Int32Value());
            sp_info->params[i].type     = SYBINT1;
            sp_info->params[i].datalen  = -1;
            sp_info->params[i].buflen   = -1;
            sp_info->params[i].buffer   = (BYTE*)number;
            break;}      

      case 4:{
            bool *boolean = new bool(value->BooleanValue());
            sp_info->params[i].type     = SYBINT1;
            sp_info->params[i].datalen  = -1;
            sp_info->params[i].buflen   = -1;
            sp_info->params[i].buffer   = (BYTE*)boolean;
            break;}
      
      case 5:{
            double *number = new double(value->NumberValue());
            sp_info->params[i].type     = SYBDECIMAL;
            sp_info->params[i].datalen  = -1;
            sp_info->params[i].buflen   = -1;
            sp_info->params[i].buffer   = (BYTE*)number;
            break;}            
        
      case 6:{
            String::Utf8Value string(value);
            sp_info->params[i].type     = SYBVARCHAR;
            sp_info->params[i].datalen  = string.length();
            sp_info->params[i].buflen   = param->Get(String::New("size"))->IntegerValue();
            sp_info->params[i].buffer   = (BYTE*)malloc(sp_info->params[i].buflen+1);
            memset(sp_info->params[i].buffer, 0, sp_info->params[i].buflen+1);
            if(sp_info->params[i].status == 0) {  
              strcpy((char*)(sp_info->params[i].buffer), *string);
            }
            break;}

      default: return ThrowException(Exception::TypeError(
                String::New("unknown param_type")));  
    }

    if(sp_info->params[i].status == 1){   //输出参数
      sp_info->params[i].datalen = 0;
    }
    else{
      sp_info->params[i].buflen  = -1;    //输入参数
    }
  } 
         
  eio_custom(EIO_Call, EIO_PRI_DEFAULT, EIO_AfterCall, sp_info);

  ev_ref(EV_DEFAULT_UC);
  sp_info->dbo->Ref();
  scope.Close(Undefined());
  return Undefined();
}


//--------------------------------------------------------------------------------------------------------
void DBConnnection::EIO_Call(eio_req *req) {
  SpInfo *sp_info = (SpInfo *)(req->data);
  
  DBConnnection* dbo = sp_info->dbo;

  int   errorCode;
  char  *name;
  int   status;
  int   type;
  int   buflen;
  int   datalen; 
  BYTE  *buffer;

  errorCode = dbrpcinit(dbo->process, sp_info->sp_name, DBRPCRECOMPILE);
  if(errorCode != SUCCEED) {
    req->result = errorCode;
    return;
  }

  for(int i=0; i<sp_info->paramCount; i++){
    name    = sp_info->params[i].name;
    status  = sp_info->params[i].status;
    type    = sp_info->params[i].type;
    buflen  = sp_info->params[i].buflen;
    datalen = sp_info->params[i].datalen;
    buffer  = sp_info->params[i].buffer;
    errorCode = dbrpcparam(dbo->process, name, (BYTE)status, type, buflen, datalen, buffer);
    if(errorCode != SUCCEED) {
      req->result = errorCode;
      return;
    }
  }

  errorCode = dbrpcsend(dbo->process);
  if(errorCode != SUCCEED) {
    req->result = errorCode;
    return;
  }
  
  errorCode = dbsqlok(dbo->process);
  req->result = errorCode;

}


//--------------------------------------------------------------------------------------------------------
int DBConnnection::EIO_AfterCall(eio_req *req) {
  ev_unref(EV_DEFAULT_UC);
  HandleScope scope;
  
  SpInfo *sp_info = (SpInfo *)(req->data);

  Local<Value>  args[4];

  if(req->result != SUCCEED) {
      const char* def_string = "[node-tds]call sp error";
      Persistent<Object> objError = process_error(sp_info->dbo->process, def_string);  
      args[0] = Local<Object>::New(objError);
      args[1] = Local<Value>::New(Null());  
      args[2] = Local<Value>::New(Null()); 
      args[3] = Local<Value>::New(Null());     
      objError.Dispose();    
  }

  else {
        Persistent<Array>   rows;
        Persistent<Object>  result;
        Persistent<Integer> ret_val;

        rows    = FetchRows(sp_info->dbo);
        result  = GetResult(sp_info->dbo);
        ret_val = GetRetVal(sp_info->dbo);

      args[0] = Local<Value>::New(Null());      
      args[1] = Local<Array>::New(rows);
      args[2] = Local<Object>::New(result); 
      args[3] = Local<Integer>::New(ret_val);  
      rows.Dispose();
      result.Dispose();
      ret_val.Dispose();

  }

  TryCatch try_catch;
  sp_info->cb->Call(sp_info->self, 4, args);
  if(try_catch.HasCaught()) {
      FatalException(try_catch);
  }

  sp_info->dbo->Unref();
  sp_info->self.Dispose();
  sp_info->cb.Dispose();
  delete sp_info;
  scope.Close(Undefined());
  return 0;
}


//获取结果集----------------------------------------------------------------------------------------------
Persistent<Array> DBConnnection::FetchRows(DBConnnection *dbo){
  HandleScope scope;
  int errorCode;
  int columnCount;
  int rowCount = 0;
  ColumnInfo *columns;
  Persistent<Array> rows = Persistent<Array>::New(Array::New());

  while( dbresults(dbo->process) != NO_MORE_RESULTS ) {
    if(DBROWS(dbo->process) != true){
      continue;
    }

    columnCount = dbnumcols(dbo->process);

    columns = new ColumnInfo[columnCount];

    for(int i=0; i<columnCount; i++) {
      columns[i].name = dbcolname(dbo->process, i+1);    
      columns[i].type = dbcoltype(dbo->process, i+1);
      columns[i].size = dbcollen(dbo->process, i+1);
    }        

    while ((errorCode = dbnextrow(dbo->process)) != NO_MORE_ROWS) { 
        if(errorCode != REG_ROW) {
          printf("dbnextrow failed!\n");
          break;
        }
        else {
          Persistent<Object> tuple = GetContent(dbo->process, columns, columnCount); 
          rows->Set(Integer::New(rowCount), tuple);
          tuple.Dispose(); 
          rowCount++;
        }
    }

    delete[] columns;           
  }

  scope.Close(Undefined());
  return rows;
}


//获取一行数据---------------------------------------------------------------------------------------------
Persistent<Object> DBConnnection::GetContent(DBPROCESS *process, ColumnInfo *columns, int count){
  HandleScope scope;
  Persistent<Object> tuple = Persistent<Object>::New(Object::New());
  
  DBDATEREC dateinfo;
  DBDATETIME temp;
  int  valueSize;
  int  buflen  = 64;
  char *buffer = new char[buflen];
  
  char *temBuf = NULL; 
  int  temBufLen; 
  int  resLen;

  for(int i=0; i<count; i++) {
    BYTE *value=dbdata(process, i+1);
    if(value==NULL){
      tuple->Set(String::New(columns[i].name), String::New("NULL"));
    }

    else{
      valueSize =dbdatlen(process, i+1);
      if(valueSize+1>buflen){
        delete[] buffer;
        buflen = valueSize+20;
        buffer = new char[buflen];
      }

      memset(buffer,0,buflen);
      memcpy(buffer,value,valueSize);
        
        switch(columns[i].type) {             
          case SYBINT4:
          case SYBINT2:
          case SYBINT1:                   
              tuple->Set(String::New(columns[i].name), Number::New(*(int*)buffer));
              break;

          case SYBINT8:    
              tuple->Set(String::New(columns[i].name), Number::New(*(long long*)buffer));
              break;
 
          case SYBBIT:
              tuple->Set(String::New(columns[i].name), Boolean::New( ( *buffer == 0) ? false:true ) );
              break;
          
          case SYBREAL:
          case SYBFLT8:
          case SYBFLTN:                
              tuple->Set(String::New(columns[i].name), Number::New(*(double*)buffer));
              break; 

          case SYBMONEY :
          case SYBMONEY4 :
          case SYBMONEYN :
          case SYBDECIMAL:  
          case SYBNUMERIC:
              temBufLen = valueSize + 50 ;
              temBuf = new char[temBufLen]; 
                       
              resLen = dbconvert(process, columns[i].type, (BYTE*)buffer, valueSize, SYBCHAR, (BYTE*)temBuf, -1);
              temBuf[resLen] = '\0';
              tuple->Set(String::New(columns[i].name), String::New(temBuf));
              delete[] temBuf;
              break; 

          case SYBDATETIME4:
              dbconvert(process, SYBDATETIME4, (BYTE*)buffer, valueSize, SYBDATETIME, (BYTE*)&temp, sizeof(DBDATETIME));
              dbdatecrack(process, &dateinfo, &temp);
              sprintf(buffer, "%d-%02d-%02d %02d:%02d:%02d:%03d" , dateinfo.year, dateinfo.month, dateinfo.day, dateinfo.hour, dateinfo.minute, dateinfo.second, dateinfo.millisecond);         
              tuple->Set(String::New(columns[i].name), String::New(buffer));
              break;

          case SYBDATETIME:  
              dbdatecrack(process, &dateinfo, (DBDATETIME *)buffer);
              sprintf(buffer, "%d-%02d-%02d %02d:%02d:%02d:%03d" , dateinfo.year, dateinfo.month, dateinfo.day, dateinfo.hour, dateinfo.minute, dateinfo.second, dateinfo.millisecond);         
              tuple->Set(String::New(columns[i].name), String::New(buffer));
              break;

          default :
              tuple->Set(String::New(columns[i].name), String::New(buffer));
              break;
        }
    }
  }
  
  delete[] buffer;
  scope.Close(Undefined());
  return tuple;
}


//获取输出参数--------------------------------------------------------------------------------------------
Persistent<Object> DBConnnection::GetResult(DBConnnection *dbo){
  HandleScope  scope;
  Persistent<Object> result = Persistent<Object>::New(Object::New());
  
  int  num_rets = dbnumrets(dbo->process);
  int  buflen   = 64;
  char *buffer  = new char[buflen];

  if(num_rets > 0) {
    for(int i=0; i<num_rets; i++) {
      BYTE* value = dbretdata(dbo->process, i+1);
      
      if(value) {
        char* name  = dbretname(dbo->process, i+1);
        int   type  = dbrettype(dbo->process, i+1);
        int   size  = dbretlen(dbo->process, i+1);
        
        if(size+1>buflen){
          delete[] buffer;
          buflen = size*2;
          buffer = new char[buflen];
        }

        memset(buffer,0,buflen);
        memcpy(buffer,value,size);

        switch(type) {
            case SYBINT8:
            case SYBINT4:
            case SYBINT2:
            case SYBINT1:
            case SYBREAL:
            case SYBFLT8: 
                result->Set(String::New(name), Number::New(*(int*)buffer) );
                break;
            case SYBBIT:
                result->Set(String::New(name), Boolean::New( (*buffer == '0') ? false:true ));
                break;            
            default :
                result->Set(String::New(name), String::New((char*)buffer));
                break;      
        }    
      }  
    }  
  }

  delete[] buffer;
  scope.Close(Undefined());
  return result;
}


//获取返回值----------------------------------------------------------------------------------------------
Persistent<Integer> DBConnnection::GetRetVal(DBConnnection *dbo) {  
  HandleScope  scope;
  Persistent<Integer> ret_val;

  if( dbhasretstat(dbo->process) ) {
      int value = dbretstatus(dbo->process);
      ret_val   = Persistent<Integer>::New(Integer::New(value));
  }
  
  scope.Close(Undefined());
  return ret_val;
}


//错误处理------------------------------------------------------------------------------------------------
Persistent<Object> DBConnnection::process_error(DBPROCESS *process, const char* def_string) {
  HandleScope  scope;
  Persistent<Object> objError = Persistent<Object>::New(Object::New()); 
    
  Error_Info *err_info = (Error_Info*)dbgetuserdata(process);     
  if(!err_info) {        
    objError->Set(String::New("error"), String::New(def_string));
  }   

  else {
    objError->Set(String::New("err_no"), Number::New(err_info->err_no));
    objError->Set(String::New("level"),  Number::New(err_info->level));

    if(err_info->msg)
      objError->Set(String::New("msg"), String::New(err_info->msg));

    if(err_info->error)
      objError->Set(String::New("error"), String::New(err_info->error));
  
    delete err_info;
    dbsetuserdata(process, NULL);
  }

  scope.Close(Undefined());
  return objError;
}


//--------------------------------------------------------------------------------------------------------
int DBConnnection::msg_handler(DBPROCESS *dbproc, DBINT msgno, int msgstate, int severity, 
      char *msgtext, char *srvname, char *procname, int line)
{                 
  enum {changed_database = 5701, changed_language = 5703 }; 
  if (msgno == changed_database || msgno == changed_language) 
    return 0;

  Error_Info *err_info = (Error_Info*)dbgetuserdata(dbproc);
  if(!err_info) {
    err_info = new Error_Info;
    dbsetuserdata(dbproc, (BYTE*)err_info);
  }

  if (msgno > 0) {
    err_info->err_no = msgno;  
    err_info->level  = severity;  
  }
  
  err_info->msg = (char *)malloc(strlen(msgtext)+1);
  strcpy(err_info->msg, msgtext);
  
  return 0;             
}


//--------------------------------------------------------------------------------------------------------
int DBConnnection::err_handler(DBPROCESS * dbproc, int severity, int dberr, int oserr, 
  char *dberrstr, char *oserrstr)
{                 
  Error_Info *err_info = (Error_Info*)dbgetuserdata(dbproc);
  if(!err_info) {
    err_info = new Error_Info;
    dbsetuserdata(dbproc, (BYTE*)err_info);
  }  

  if(dberr) { 
    err_info->err_no = dberr;  
    err_info->level  = severity;               
    err_info->error = (char *)malloc(strlen(dberrstr)+1);
    strcpy(err_info->error, dberrstr);
  }
  else {
    err_info->error = (char *)malloc(strlen(oserrstr)+1);
    strcpy(err_info->error, oserrstr);
  }

  return INT_CANCEL;            
}


//--------------------------------------------------------------------------------------------------------
Persistent<FunctionTemplate> DBConnnection::constructor_template;
extern "C" void init (v8::Handle<Object> target) {
  DBConnnection::Init(target);
}


//--------------------------------------------------------------------------------------------------------
void DBConnnection::RecordSpName(DBPROCESS * dbproc, char *SpName) {
    dbsetuserdata(dbproc, (BYTE*)SpName);     
} 
