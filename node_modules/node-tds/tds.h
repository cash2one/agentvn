/*
  Copyright (c) 2012, jiang <410501700@qq.com>

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted, provided that the above
  copyright notice and this permission notice appear in all copies.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
  ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
  OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
*/

#ifndef TDS_H
#define TDS_H

#include <v8.h>
#include <node.h>
#include <string.h>
#include <stdlib.h>

#define MSDBLIB

// #include <sybfront.h>
#include "./sybdb.h"

using namespace v8;
using namespace node;

class DBConnnection;

struct ColumnInfo{ 
    char *name; 
    int  type; 
    int  size; 
};

class ConnInfo{
  public:
    Persistent<Object>  self;
    Persistent<Function>  cb;   
    DBConnnection  *dbo;
    char *host;
    char *username;
    char *password;
  
  public:
    ConnInfo(){
      host = NULL;
      username = NULL;
      password = NULL;
    }

    ~ConnInfo(){
      if(host){
        free(host);
        host = NULL;
      }
      if(username){
        free(username);
        username = NULL;
      }
      if(password){
        free(password);
        password = NULL;
      }    
    }     

};

class UseInfo{
  public:
    Persistent<Function>  cb;
    DBConnnection  *dbo;
    char  *dbname;

  public:
    UseInfo(){
      dbname = NULL;
    }

    ~UseInfo(){
      if(dbname){
        free(dbname);
        dbname = NULL;
      }
    }       
};


class QueryInfo{
  public:
    Persistent<Object>  self;
    Persistent<Function>  cb;
    DBConnnection  *dbo;
    char  *slqString;
    int   errorInfo; 

  public:
    QueryInfo(){
      slqString = NULL;
    }

    ~QueryInfo(){
      if(slqString){
        free(slqString);
        slqString = NULL;
      }
    } 

};

class ParamInfo {
  public:  
    int       type;
    char      *name;
    BYTE      *buffer;
    int       datalen;    
    int       buflen;
    int       status;
  
  public:
    ParamInfo(){
      name = NULL;
      buffer = NULL;
    }

    ~ParamInfo(){
      if(name){
        free(name);
        name = NULL;
      }

      if(buffer){
        free(buffer);
        buffer = NULL;
      }
    } 

};

class SpInfo {
  public:
    Persistent<Object>  self;
    Persistent<Function>  cb;
    DBConnnection  *dbo;
    char      *sp_name;
    ParamInfo *params;
    int  paramCount;

  public:
    SpInfo(){
      sp_name = NULL;
      params  = NULL;
    }

    ~SpInfo(){
      if(sp_name){
        free(sp_name);
        sp_name = NULL;
      }

      if(params){
        delete[] params;
        params = NULL;
      }
    } 
      
};

class Error_Info {
  public:
    int   err_no;
    int   level;
    char  *msg;
    char  *error;

  public:  
    Error_Info(){
      msg = NULL;
      error = NULL;
    }

    ~Error_Info(){
      if(msg){
        free(msg);
        msg = NULL;
      }

      if(error){
        free(error);
        error = NULL;
      }
    }

};

class DBConnnection : public node::ObjectWrap {
 public:

    DBPROCESS   *process;  
    LOGINREC    *loginrec;

 public:

  DBConnnection() { process=NULL; loginrec=NULL; }

  ~DBConnnection() {}

  static Persistent<FunctionTemplate> constructor_template;

  static void Init(v8::Handle<Object> target);

  static Handle<Value> New(const Arguments& args);

  static Handle<Value> Init_(const Arguments& args);

  static Handle<Value> Exit(const Arguments& args);

  static Handle<Value> Open(const Arguments& args);

  static void EIO_Open(eio_req *req); 

  static int EIO_AfterOpen(eio_req *req);

  static Handle<Value> Close(const Arguments& args);
  
  static Handle<Value> Use(const Arguments& args);

  static void EIO_Use(eio_req *req); 

  static int EIO_AfterUse(eio_req *req);
  
  static Handle<Value> Query(const Arguments& args);
  
  static void EIO_Query(eio_req *req); 

  static int EIO_AfterQuery(eio_req *req);
  
  static Handle<Value> Call(const Arguments& args);

  static void EIO_Call(eio_req *req); 

  static int EIO_AfterCall(eio_req *req);
 
  static Persistent<Array> FetchRows(DBConnnection *);

  static Persistent<Object> GetContent(DBPROCESS *, ColumnInfo *, int );

  static Persistent<Object> GetResult(DBConnnection *);

  static Persistent<Integer> GetRetVal(DBConnnection *);

  static Persistent<Object> process_error(DBPROCESS *, const char*);

  static int err_handler(DBPROCESS *, int, int, int, char *, char *);

  static int msg_handler(DBPROCESS *, DBINT, int, int, char *, char *, char *, int);
  
  static void RecordSpName(DBPROCESS * , char *);
};

#define STR_CPY(SRC, DEC)                                               \
   SRC = (char *)malloc(DEC.length() +1);                               \
   strcpy(SRC, *DEC);                     


#define CHECK_RET(VAR, FUN)                                             \
  if(VAR!=SUCCEED)                                                      \
    return ThrowException(Exception::TypeError(                         \
                                               String::New("[node-freetds]" #FUN "faild")));

#define REQ_ARGS(N)                                                     \
  if (args.Length() != (N))                                              \
    return ThrowException(Exception::TypeError(                         \
                                               String::New("Expected " #N "arguments")));

#define REQ_STR_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsString())                     \
    return ThrowException(Exception::TypeError(                         \
                                               String::New("Argument " #I " must be a string"))); \
  String::Utf8Value VAR(args[I]->ToString());

#define REQ_STR_OR_NULL_ARG(I, VAR)                                             \
  if ( args.Length() <= (I) || (!args[I]->IsString() && !args[I]->IsNull()) )                     \
    return ThrowException(Exception::TypeError(                         \
                                               String::New("Argument " #I " must be a string or null"))); \
  String::Utf8Value VAR(args[I]->ToString());

#define REQ_FUN_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsFunction())                   \
    return ThrowException(Exception::TypeError(                         \
                                               String::New("Argument " #I " must be a function"))); \
  Local<Function> VAR = Local<Function>::Cast(args[I]);

#define REQ_ARR_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsArray())                   \
    return ThrowException(Exception::TypeError(                         \
                                               String::New("Argument " #I " must be an array"))); \
  Local<Array> VAR = Local<Array>::Cast(args[I]);

#define REQ_EXT_ARG(I, VAR)                                             \
  if (args.Length() <= (I) || !args[I]->IsExternal())                   \
    return ThrowException(Exception::TypeError(                         \
                                               String::New("Argument " #I " invalid"))); \
  Local<External> VAR = Local<External>::Cast(args[I]);

#define OPT_INT_ARG(I, VAR, DEFAULT)                                    \
  int VAR;                                                              \
  if (args.Length() <= (I)) {                                           \
    VAR = (DEFAULT);                                                    \
  } else if (args[I]->IsInt32()) {                                      \
    VAR = args[I]->Int32Value();                                        \
  } else {                                                              \
    return ThrowException(Exception::TypeError(                         \
                                               String::New("Argument " #I " must be an integer"))); \
  }


#endif
