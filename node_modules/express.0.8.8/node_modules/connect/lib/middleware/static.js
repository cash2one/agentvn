
/*!
 * Connect - static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * MIT Licensed
 */

/**
 * Module dependencies.
 */

var send = require('send')
  , utils = require('../utils')
  , parse = utils.parseUrl
  , url = require('url')
  , fs = require('fs');

/**
 * Static:
 *
 *   Static file server with the given `root` path.
 *
 * Examples:
 *
 *     var oneDay = 86400000;
 *
 *     connect()
 *       .use(connect.static(__dirname + '/public'))
 *
 *     connect()
 *       .use(connect.static(__dirname + '/public', { maxAge: oneDay }))
 *
 * Options:
 *
 *    - `maxAge`     Browser cache maxAge in milliseconds. defaults to 0
 *    - `hidden`     Allow transfer of hidden files. defaults to false
 *    - `redirect`   Redirect to trailing "/" when the pathname is a dir. defaults to true
 *
 * @param {String} root
 * @param {Object} options
 * @return {Function}
 * @api public
 */

exports = module.exports = function static(root, options){
  options = options || {};
  options.root = root

  // root required
  if (!root) throw new Error('static() root path required');

  // default redirect
  var redirect = false === options.redirect ? false : true;

  init_url_map(options.app, options.url_map_config)

  return function static(req, res, next) {
    if ('GET' != req.method && 'HEAD' != req.method) return next();
    var path = parse(req).pathname;
    var type = send.mime.lookup(path)

    function directory() {
      if (!redirect) return next();
      var pathname = url.parse(req.originalUrl).pathname;
      res.statusCode = 301;
      res.setHeader('Location', pathname + '/');
      res.end('Redirecting to ' + utils.escape(pathname) + '/');
    }

    function error(err) {
      if (404 == err.status) return next();
      next(err);
    }

    static_route(req, res, path, options, function(root, path) {
      send(req, path)
        .maxage(options.maxAge || 0)
        .root(root)
        .hidden(options.hidden)
        .on('error', error)
        .on('directory', directory)
        .pipe(res, type)
    })
  };
};

function static_route(req, res, path, options, cb) {
    var root    = options.root
    var _root   = options._root
    var usegzip = options.usegzip

    path = url_path_map(req, root) || path
    path = relative_path(path, root)

    choice_root(root, _root, path, function(root) {
        gzip_file(req, res, root, path, usegzip, function(path) {
            cb(root, path)
        })
    })
}

function choice_root(root, _root, path, cb) {
    if (!_root) {
        cb(root); return;
    }

    fs.stat(root + path, function(err, stat1) {
        if (err) {
            cb(root); return;
        }

        fs.stat(_root + path, function(err, stat2) {
            if (err) {
                cb(root); return;
            }

            if (stat1.mtime < stat2.mtime) {
                cb(_root)
            }
            else {
                cb(root)
            }
        })
    })
}

function gzip_file(req, res, root, path, usegzip, cb) {
    if (!usegzip) {
        cb(path); return;
    }

    var type = send.mime.lookup(path)
    if (!can_gzip(req, type)) {
        cb(path); return;
    }

    fs.stat(root + path + '.gz', function(err, stat) {
        if (err) {
            cb(path); return;
        }

        res.setHeader('Content-Encoding', 'gzip')
        cb(path + '.gz')
    })
}

/**
 * Expose mime module.
 * 
 * If you wish to extend the mime table use this
 * reference to the "mime" module in the npm registry.
 */

exports.mime = send.mime;

function init_url_map(app, url_map_config) {
    if (!url_map_config) {
        return
    }

    try {
        var s = fs.readFileSync(url_map_config, 'utf8')
        var sa = s.split('\n')//
        for (var i = 1; i < sa.length; ++i) {
            if(sa[i] == ""){
              break
            }
            var d = sa[i].trim().split(',')
            var url = d[0]
            var path = d[1]

            app.url_map = app.url_map || {}
            app.url_map[url] = path
        }

        for (var k in app.url_map) {
            console.log(k, '\t', app.url_map[k])
        }
    }
    catch (e) {
        console.log('no url map config', e)
    }
}

function url_path_map(req, root) {
    var url_map = req.app.url_map
    if (!url_map) {
        return
    }

    var url = req.url
    if (!url_map[url]) {
        return
    }

    var path = root + url_map[url]
    return path
}

function relative_path(path, root) {
    var i = path.indexOf(root)
    if (i !== 0) {
        return path
    }

    return path.substring(root.length)
}

var can_gzip_type = {
    'text/html'              : true,
    'text/css'               : true,
    'application/javascript' : true,
}

function can_gzip(req, type) {
    if (!req.headers['accept-encoding']) {
        return false
    }

    if (req.headers['accept-encoding'].indexOf('gzip') < 0) {
        return false
    }

    return can_gzip_type[type]
}
